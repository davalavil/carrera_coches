<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carrera de Coches Three.js</title>
    <script src="https://cdn.tailwindcss.com/dist/browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: white;
        }
         /* Ajuste para el contenedor del canvas */
        #canvasContainer {
             width: 90vw;
             max-width: 1000px; /* Ajustar si es necesario */
             height: 70vh; /* Un poco más de altura */
             max-height: 650px;
             display: flex;
             justify-content: center;
             align-items: center;
             margin-bottom: 10px;
             border-radius: 8px;
             box-shadow: 0 0 15px rgba(0,0,0,0.5);
             background-color: #5a4d41; /* Color tierra */
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 8px;
             /* El fondo lo da el contenedor o la escena */
        }
        button {
            font-family: 'Press Start 2P', cursive;
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin-top: 15px; /* Un poco más de margen */
            cursor: pointer;
            border-radius: 8px;
            box-shadow: 0 4px #999;
            transition: all 0.1s ease;
        }
        button:hover {
            background-color: #45a049;
        }
        button:active {
            background-color: #3e8e41;
            box-shadow: 0 2px #666;
            transform: translateY(2px);
        }
        .controls-info {
            margin-top: 15px;
            font-size: 10px;
            text-align: center;
            line-height: 1.5;
        }
    </style>
</head>
<body>

    <h1 class="text-xl mb-2">Carrera Rectangular</h1>

    <div id="canvasContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <button id="restartButton">Reiniciar</button>

    <div class="controls-info">
        <p>Coche 1 (Rojo): W (Acelerar), S (Frenar), A (Izquierda), D (Derecha)</p>
        <p>Coche 2 (Azul): ↑ (Acelerar), ↓ (Frenar), ← (Izquierda), → (Derecha)</p>
    </div>

    <script>
        // --- Variables Globales ---
        let scene, camera, renderer;
        let car1, car2;
        let trackLimits = []; // Array para guardar los límites (visibles)
        const keysPressed = {};

        // --- Constantes ---
        const CAR_WIDTH = 1.5; // Ajustar tamaño si se desea
        const CAR_LENGTH = 3;
        const MAX_SPEED = 0.35; // Ajustar velocidad si se desea
        const ACCELERATION = 0.012;
        const BRAKE_FORCE = 0.022;
        const FRICTION = 0.98;
        const TURN_SPEED = 0.05;

        // Dimensiones de la pista rectangular
        const TRACK_OUTER_WIDTH = 40; // Ancho exterior
        const TRACK_OUTER_HEIGHT = 65; // Alto exterior
        const TRACK_INNER_WIDTH = 25; // Ancho interior
        const TRACK_INNER_HEIGHT = 50; // Alto interior
        const BORDER_THICKNESS = 1; // Grosor visual de los muros

        // --- Inicialización ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x5a4d41); // Color tierra

            const frustumSize = 75; // Ajustar zoom para ver bien la pista
            const canvas = document.getElementById('gameCanvas');
            const aspect = canvas.clientWidth / canvas.clientHeight;

            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2,
                frustumSize * aspect / 2,
                frustumSize / 2,
                frustumSize / -2,
                1,
                1000
            );
            camera.position.set(0, 50, 0);
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            scene.add(directionalLight);

            // *** Crear Pista Rectangular Simple ***
            createTrack();

            // Posición inicial Z en la recta inferior
            const startZ = TRACK_OUTER_HEIGHT / 2 - 5;
            // Calcular X inicial para que estén dentro del carril
            const laneCenter = (TRACK_OUTER_WIDTH + TRACK_INNER_WIDTH) / 4;
            car1 = createCar(0xff0000, -laneCenter / 2, startZ);
            car2 = createCar(0x0000ff, laneCenter / 2, startZ);
            scene.add(car1);
            scene.add(car2);

            resetGame(); // Llama a resetGame para posicionar correctamente

            document.addEventListener('keydown', (event) => {
                keysPressed[event.key.toLowerCase()] = true;
                keysPressed[event.code] = true;
            });
            document.addEventListener('keyup', (event) => {
                keysPressed[event.key.toLowerCase()] = false;
                keysPressed[event.code] = false;
            });

            document.getElementById('restartButton').addEventListener('click', resetGame);
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize();
            animate();
        }

        function onWindowResize() {
            const container = document.getElementById('canvasContainer');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const aspect = width / height;
            const frustumSize = 75; // Mantener consistente con init
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        // --- Crear Pista (RECTANGULAR SIMPLE) ---
        function createTrack() {
            trackLimits.forEach(limit => scene.remove(limit));
            trackLimits = [];

            const borderMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc }); // Color bordes
            const wallHeight = 1; // Altura visual de los muros

            // --- Límites Exteriores ---
            const outerLeft = new THREE.Mesh(new THREE.BoxGeometry(BORDER_THICKNESS, wallHeight, TRACK_OUTER_HEIGHT + BORDER_THICKNESS), borderMaterial);
            outerLeft.position.set(-(TRACK_OUTER_WIDTH / 2 + BORDER_THICKNESS / 2), wallHeight / 2, 0);
            scene.add(outerLeft);
            trackLimits.push(outerLeft);

            const outerRight = new THREE.Mesh(new THREE.BoxGeometry(BORDER_THICKNESS, wallHeight, TRACK_OUTER_HEIGHT + BORDER_THICKNESS), borderMaterial);
            outerRight.position.set(TRACK_OUTER_WIDTH / 2 + BORDER_THICKNESS / 2, wallHeight / 2, 0);
            scene.add(outerRight);
            trackLimits.push(outerRight);

            const outerTop = new THREE.Mesh(new THREE.BoxGeometry(TRACK_OUTER_WIDTH + BORDER_THICKNESS, wallHeight, BORDER_THICKNESS), borderMaterial);
            outerTop.position.set(0, wallHeight / 2, -(TRACK_OUTER_HEIGHT / 2 + BORDER_THICKNESS / 2));
            scene.add(outerTop);
            trackLimits.push(outerTop);

            const outerBottom = new THREE.Mesh(new THREE.BoxGeometry(TRACK_OUTER_WIDTH + BORDER_THICKNESS, wallHeight, BORDER_THICKNESS), borderMaterial);
            outerBottom.position.set(0, wallHeight / 2, TRACK_OUTER_HEIGHT / 2 + BORDER_THICKNESS / 2);
            scene.add(outerBottom);
            trackLimits.push(outerBottom);

            // --- Límites Interiores ---
            const innerLeft = new THREE.Mesh(new THREE.BoxGeometry(BORDER_THICKNESS, wallHeight, TRACK_INNER_HEIGHT - BORDER_THICKNESS), borderMaterial);
            innerLeft.position.set(-(TRACK_INNER_WIDTH / 2 - BORDER_THICKNESS / 2), wallHeight / 2, 0);
            scene.add(innerLeft);
            trackLimits.push(innerLeft);

            const innerRight = new THREE.Mesh(new THREE.BoxGeometry(BORDER_THICKNESS, wallHeight, TRACK_INNER_HEIGHT - BORDER_THICKNESS), borderMaterial);
            innerRight.position.set(TRACK_INNER_WIDTH / 2 - BORDER_THICKNESS / 2, wallHeight / 2, 0);
            scene.add(innerRight);
            trackLimits.push(innerRight);

            const innerTop = new THREE.Mesh(new THREE.BoxGeometry(TRACK_INNER_WIDTH - BORDER_THICKNESS, wallHeight, BORDER_THICKNESS), borderMaterial);
            innerTop.position.set(0, wallHeight / 2, -(TRACK_INNER_HEIGHT / 2 - BORDER_THICKNESS / 2));
            scene.add(innerTop);
            trackLimits.push(innerTop);

            const innerBottom = new THREE.Mesh(new THREE.BoxGeometry(TRACK_INNER_WIDTH - BORDER_THICKNESS, wallHeight, BORDER_THICKNESS), borderMaterial);
            innerBottom.position.set(0, wallHeight / 2, TRACK_INNER_HEIGHT / 2 - BORDER_THICKNESS / 2);
            scene.add(innerBottom);
            trackLimits.push(innerBottom);

            // --- Línea de salida/meta ---
            const finishLineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            // Ancho de la línea = ancho del carril
            const laneWidth = TRACK_OUTER_WIDTH - TRACK_INNER_WIDTH;
            const finishLineGeometry = new THREE.PlaneGeometry(laneWidth - BORDER_THICKNESS * 2, 1.5); // Ajustar ancho
            const finishLine = new THREE.Mesh(finishLineGeometry, finishLineMaterial);
            finishLine.rotation.x = -Math.PI / 2;
            // Posicionar en la recta inferior
            finishLine.position.set(0, 0.05, TRACK_OUTER_HEIGHT / 2 - 2); // Un poco antes del borde
            scene.add(finishLine);
        }

        // --- Crear Coche ---
        function createCar(color, x, z) {
            const carGeometry = new THREE.BoxGeometry(CAR_WIDTH, 0.5, CAR_LENGTH);
            const carMaterial = new THREE.MeshLambertMaterial({ color: color });
            const carMesh = new THREE.Mesh(carGeometry, carMaterial);
            carMesh.position.set(x, 0.25, z); // Posición Y sobre el suelo
            carMesh.userData = {
                speed: 0,
                angle: Math.PI // Ángulo inicial hacia arriba (-Z)
            };
             carMesh.rotation.y = carMesh.userData.angle;
            return carMesh;
        }

        // --- Reiniciar Juego ---
        function resetGame() {
            // Reposicionar coches en la nueva línea de salida
            const startZ = TRACK_OUTER_HEIGHT / 2 - 5;
            const laneCenter = (TRACK_OUTER_WIDTH - TRACK_INNER_WIDTH) / 2; // Ancho del carril
            const carSpacing = laneCenter / 2; // Espacio entre coches

            car1.position.set(-carSpacing / 2, 0.25, startZ);
            car1.rotation.y = Math.PI;
            car1.userData.speed = 0;
            car1.userData.angle = Math.PI;

            car2.position.set(carSpacing / 2, 0.25, startZ);
            car2.rotation.y = Math.PI;
            car2.userData.speed = 0;
            car2.userData.angle = Math.PI;

            for (const key in keysPressed) {
                keysPressed[key] = false;
            }
        }

        // --- Actualizar Movimiento del Coche (Sin cambios en la lógica) ---
        function updateCarMovement(car, controls) {
            const carData = car.userData;
            let accelerationInput = 0;
            let turnInput = 0;

            // Aceleración y Freno
            if (keysPressed[controls.accelerate]) accelerationInput = ACCELERATION;
            if (keysPressed[controls.brake]) {
                if (carData.speed > 0.01) accelerationInput = -BRAKE_FORCE;
                else if (carData.speed > -MAX_SPEED / 2) accelerationInput = -ACCELERATION / 1.5;
            }

            carData.speed += accelerationInput;
            carData.speed *= FRICTION;

            // Limitar velocidad
            if (carData.speed > MAX_SPEED) carData.speed = MAX_SPEED;
            if (carData.speed < -MAX_SPEED / 2) carData.speed = -MAX_SPEED / 2;
            if (Math.abs(carData.speed) < 0.005) carData.speed = 0;

            // Giro
            if (Math.abs(carData.speed) > 0.01) {
                if (keysPressed[controls.left]) turnInput = TURN_SPEED;
                if (keysPressed[controls.right]) turnInput = -TURN_SPEED;
                if (carData.speed < 0) turnInput *= -1;
            }

            carData.angle += turnInput;
            car.rotation.y = carData.angle;

            // Actualizar Posición
            const deltaX = Math.sin(carData.angle) * carData.speed;
            const deltaZ = Math.cos(carData.angle) * carData.speed;
            const nextPosition = car.position.clone();
            nextPosition.x -= deltaX;
            nextPosition.z -= deltaZ;

            // Detección de Colisiones Simple (AABB contra límites VISIBLES)
            let collision = false;
            const halfWidth = CAR_WIDTH / 2;
            const halfLength = CAR_LENGTH / 2;
            const nextCarBox = new THREE.Box3(
                 new THREE.Vector3(nextPosition.x - halfWidth, nextPosition.y - 0.25, nextPosition.z - halfLength),
                 new THREE.Vector3(nextPosition.x + halfWidth, nextPosition.y + 0.25, nextPosition.z + halfLength)
             );

            // Comprobar colisión contra los límites en trackLimits
            for (const limit of trackLimits) {
                const limitBox = new THREE.Box3().setFromObject(limit);
                if (nextCarBox.intersectsBox(limitBox)) {
                    collision = true;
                    break;
                }
            }

            // Mover si no hay colisión
            if (!collision) {
                car.position.copy(nextPosition);
            } else {
                carData.speed *= 0.2; // Frenar
                 if (Math.abs(carData.speed) < 0.01) carData.speed = 0;
            }
        }

        // --- Bucle de Animación ---
        function animate() {
            requestAnimationFrame(animate);
            updateCarMovement(car1, { accelerate: 'w', brake: 's', left: 'a', right: 'd' });
            updateCarMovement(car2, { accelerate: 'ArrowUp', brake: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' });
            renderer.render(scene, camera);
        }

        // --- Iniciar ---
        window.onload = init;

    </script>

</body>
</html>
